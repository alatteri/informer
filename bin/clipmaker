#!/usr/bin/env python

# ------------------------------------------------------------------------------
# START BOOTSTRAP
# ------------------------------------------------------------------------------
try:
    import instinctual
except ImportError, e:
    import os
    import sys
    lib = os.sep.join(os.path.abspath(__file__).split(os.sep)[:-2] + ['lib'])
    sys.path.append(lib)
    import sitecustomize
# ------------------------------------------------------------------------------
# END BOOTSTRAP
# ------------------------------------------------------------------------------

import os
import sys
import errno
import tempfile
import commands
from pprint import pprint
from datetime import datetime

import instinctual
from instinctual import settings
from instinctual.informer.models import *

LOG = instinctual.getLogger(__file__)

root = os.sep.join(os.path.abspath(__file__).split(os.sep)[:-2])
tmpdir  = root + '/tmp'
pending = root + '/pending.png'
ffmpeg  = root + '/third_party/bin/ffmpeg'
qt_fast = root + '/third_party/bin/qt-faststart'

def main():
    SYSTEM("cal")
    # get the lock
    lockfile = tmpdir + '/lockfile'

    try:
    	MKDIR(tmpdir)
        flag = os.O_CREAT | os.O_EXCL | os.O_WRONLY
        fd = os.open(lockfile, flag, 0600)
        os.write(fd, str(os.getpid()))
        os.close(fd)
    except OSError, e:
        LOG.info("Unable to acquire lock.")
        sys.exit(1)
    except Exception, e:
        LOG.fatal("Unable to acquire lock: unknown error: %s" % e)
        sys.exit(1)

    try:
        try:
            # get the clips that need updating
            clip_ids = Frame.objects.filter(in_clip=False).values('clip').distinct()
            LOG.info("Lock acquired: %s clips to process..." % len(clip_ids))

            for clip_id in clip_ids:
                makeclip(clip_id)
        except Exception, e:
            LOG.fatal(str(e))
            sys.exit(1)
    finally:
        LOG.info("removing lockfile")
        os.unlink(lockfile)

def makeclip(clip_id):
    clip = Clip.objects.get(id=clip_id['clip'])
    LOG.info("+ working on clip id %s" % clip.id)

    # grab info about the frames that need processing
    max = None
    frames = {}
    for frame in Frame.objects.filter(clip=clip):
        frame.in_clip = True
        frames[frame.number] = frame
        if not max or frame.number > max:
            max = frame.number

    # create the temp workspace
    MKDIR(tmpdir)
    prefix = "%s-%s-%s-" % ('clipmaker', datetime.now().strftime("%Y.%m.%d-%H.%M.%S"), clip.id)
    workspace = tempfile.mkdtemp('', prefix, tmpdir)

    to_delete = []
    pattern = workspace + '/' + '%06d.png'
    for number in range(clip.start, max + 1):
        if number in frames:
            print "Frame [%s] %s" % (number, frames[number].get_image_filename())
            source = frames[number].get_image_filename()
        else:
            print "WARN: frame %s is missing" % (number)
            source = pending
        dest = pattern % (number)
        os.symlink(source, dest)
        to_delete.append(dest)

    # create the clip
    slow = workspace + '/' + 'slow.mov'
    cmd = "%s -r %s -i %s -vcodec libx264 -f mov -threads 4 %s" % (ffmpeg, clip.rate, pattern, slow)
    SYSTEM(cmd)

    # qt-faststart it
    fast = workspace + '/' + 'fast.mov'
    cmd = "%s %s %s" % (qt_fast, slow, fast)
    SYSTEM(cmd)

    # copy the movie...
    UNLINK(clip.get_movie_filename())

    f = open(fast, 'rb')
    clip.save_movie_file('%s.mov' % clip.id, f.read(), True)

    # save it
    for frame in frames.values():
        frame.in_clip = True
        frame.save()

    # cleanup
    UNLINK(slow)
    UNLINK(fast)

    for delete_me in to_delete:
        UNLINK(delete_me)

    os.rmdir(workspace)

# ------------------------------------------------------------------------------
# utility functions
# ------------------------------------------------------------------------------
def UNLINK(path):
    try:
        os.unlink(path)
    except OSError, e:
        if errno.ENOENT != e.errno:
            raise e

def SYSTEM(cmd):
    (result, output) = commands.getstatusoutput(cmd + 'x')

    if 0 != result:
        msg = "Non-Zero (%s) status returned from %s:" % (result, cmd)
        raise ValueError(msg + "\n---- BEGIN ----\n%s\n---- END ----" % output)

def MKDIR(dir):
    try:
        os.mkdir(dir)
    except OSError, e:
        if errno.EEXIST != e.errno:
            raise e

# ------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
