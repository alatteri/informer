#!/usr/bin/env python

# ------------------------------------------------------------------------------
# START BOOTSTRAP
# ------------------------------------------------------------------------------
try:
    import instinctual
except ImportError, e:
    import os
    import sys
    lib = os.sep.join(os.path.abspath(__file__).split(os.sep)[:-2] + ['lib'])
    print "hey lib is:", lib
    sys.path.append(lib)
    import sitecustomize
# ------------------------------------------------------------------------------
# END BOOTSTRAP
# ------------------------------------------------------------------------------

import re
import sys
import time
from optparse import OptionParser

import instinctual
from instinctual import settings
from instinctual.informer.client import Client, ClientConnectionError

LOG = instinctual.getLogger(sys.argv[0])

ok_actions = ('get_notes', 'get_elements', 'update_note', 'update_element', 'new_note')
ok_actions_str = '|'.join(ok_actions)

parser = OptionParser("usage: gateway " + \
                      "--setup=<file> " + \
                      "--action=(%s) " % ok_actions_str + \
                      "[--infile=<infile>] " + \
                      "[--outfile=<outfile>]")

parser.add_option('-s', '--setup',
                  action = 'store', dest = 'setup', default = None,
                  help = "the path of the batch setup file (required)")

parser.add_option('-a', '--action',
                  action = 'store', dest = 'action', default = None,
                  help = "the action to perform: (%s) (required)" % ok_actions_str)

parser.add_option('-o', '--outfile',
                  action = 'store', dest = 'outfile', default = None,
                  help = "the output file for saving results (default: stdout)")

parser.add_option('-i', '--infile',
                  action = 'store', dest = 'infile', default = None,
                  help = "the input file for reading data (default: stdin)")

# ------------------------------------------------------------------------------
class Gateway(object):
    format = "%D %I:%M%p"
    def __init__(self):
        (options, args) = parser.parse_args()
        LOG.info("Gateway called with options [%s] args [%s]" % (options, args))

        if options.setup is None:
            parser.error("A setup file must be specified")

        if options.action is None:
            parser.error("An action must be specified")

        if options.action not in ok_actions:
            one_of = ", ".join(ok_actions)
            parser.error("The action specified must be one of: " + one_of)

        self.options = options
        self.setup   = options.setup
        self.action  = options.action

    def run(self):
        LOG.info("action: %s" % (self.action))
        LOG.info("setup: %s" % (self.setup))

        outfile = sys.stdout
        if self.options.outfile:
            outfile = open(self.options.outfile, 'w')

        infile = sys.stdin
        if self.options.infile:
            infile = open(self.options.infile, 'r')

        try:
            if self.action == 'get_notes':
                result = self.getNotes()
                data = self.serializeNotes(result)
                outfile.write(data)
            elif self.action == 'update_note':
                input = self.parseInfile(infile)
                result = self.updateNote(input[0])
                data = self.serializeNotes(result)
                outfile.write(data)
            elif self.action == 'new_note':
                input = self.parseInfile(infile)
                self.newNote(input[0])
            elif self.action == 'get_elements':
                result = self.getElements()
                data = self.serializeElements(result)
                outfile.write(data)
            elif self.action == 'update_element':
                input = self.parseInfile(infile)
                result = self.updateElement(input[0])
                data = self.serializeElements(result)
                outfile.write(data)
        except ClientConnectionError, e:
            LOG.error("Could not reach database: %s" % (e))
            sys.exit(2)

    def parseInfile(self, infile):
        data = []
        _re = re.compile(r'^(\w+):\s*(.+)$')
        count = int(infile.readline()[:-1])
        for line in infile.xreadlines():
            match = _re.search(line)
            if match != None:
                key = match.group(1)
                val = match.group(2)
                if key == 'id' or 0 == len(data):
                    data.append({})
                data[-1][key] = val

        if len(data) != count:
            msg = "The number of elements read did not match count"
            LOG.error(msg)
            raise IOError(msg)

        return data

    def newNote(self, data):
        client = Client()
        LOG.info("Running newNote()")
        client.newNote(self.setup, data)

    def updateNote(self, data):
        client = Client()
        LOG.info("Running updateNote()")
        return client.updateNote(self.setup, data)

    def getNotes(self):
        """
        Returns an array of note objects
        """
        client = Client()

        LOG.info("Running getNotes()")
        notes = client.getNotes(self.setup)

        LOG.info("Lookup found: %s notes" % (len(notes)))
        LOG.info("Found this: %s", (notes))

        return notes


    def serializeNotes(self, notes):
        data = ''
        data += "%s\n" % (len(notes))

        # int(time.mktime(note.create_on.timetuple()))
        # 1191136120.0
        for note in notes:
            LOG.info("---> note: %s" % (note))
            data += "id: %s\n" % (note.id)
            data += "text: %s\n" % (note.text)
            data += "is_checked: %s\n" % (int(note.is_checked))
            data += "created_by: %s\n" % (note.created_by)
            created_on = int(time.mktime(note.created_on.timetuple()))
            data += "created_on: %s\n" % (created_on)
            data += "modified_by: %s\n" % (note.modified_by)
            modified_on = int(time.mktime(note.modified_on.timetuple()))
            data += "modified_on: %s\n" % (modified_on)

        return data

    def getElements(self):
        """
        Returns an array of element objects
        """
        client = Client()

        LOG.info("Running getElements()")
        elements = client.getElements(self.setup)

        LOG.info("Lookup found: %s elements" % (len(elements)))
        LOG.info("Found this: %s", (elements))

        return elements

    def updateElement(self, data):
        client = Client()
        LOG.info("Running updateElement()")
        return client.updateElement(self.setup, data)

    def serializeElements(self, elements):
        data = ''
        data += "%s\n" % (len(elements))

        for element in elements:
            LOG.info("---> element: %s" % (element))
            data += "id: %s\n" % (element.id)
            data += "kind: %s\n" % (element.kind)
            data += "text: %s\n" % (element.text)
            data += "is_checked: %s\n" % (int(element.is_checked))
            data += "created_by: %s\n" % (element.created_by)
            created_on = int(time.mktime(element.created_on.timetuple()))
            data += "created_on: %s\n" % (created_on)

        return data

# ------------------------------------------------------------------------------
if __name__ == '__main__':
    app = Gateway()
    app.run()
