#!/usr/bin/env python

# ------------------------------------------------------------------------------
# START BOOTSTRAP
# ------------------------------------------------------------------------------
try:
    import instinctual
except ImportError, e:
    import os
    import sys
    lib = os.sep.join(os.path.abspath(__file__).split(os.sep)[:-2] + ['lib'])
    print "hey lib is:", lib
    sys.path.append(lib)
    import sitecustomize
# ------------------------------------------------------------------------------
# END BOOTSTRAP
# ------------------------------------------------------------------------------

import re
import sys
from optparse import OptionParser

import instinctual
from instinctual import settings
from instinctual.informer.client import Client, ClientConnectionError

LOG = instinctual.getLogger(sys.argv[0])

ok_actions = ('get_notes', 'get_elements', 'update_note', 'new_note')
ok_actions_str = '|'.join(ok_actions)

parser = OptionParser("usage: gateway " + \
                      "--setup=<file> " + \
                      "--action=(%s) " % ok_actions_str + \
                      "[--infile=<infile>] " + \
                      "[--outfile=<outfile>]")

parser.add_option('-s', '--setup',
                  action = 'store', dest = 'setup', default = None,
                  help = "the path of the batch setup file (required)")

parser.add_option('-a', '--action',
                  action = 'store', dest = 'action', default = None,
                  help = "the action to perform: (%s) (required)" % ok_actions_str)

parser.add_option('-o', '--outfile',
                  action = 'store', dest = 'outfile', default = None,
                  help = "the output file for saving results (default: stdout)")

parser.add_option('-i', '--infile',
                  action = 'store', dest = 'infile', default = None,
                  help = "the input file for reading data (default: stdin)")

# ------------------------------------------------------------------------------
class Gateway(object):
    format = "%D %I:%M%p"
    def __init__(self):
        (options, args) = parser.parse_args()
        LOG.info("Gateway called with options [%s] args [%s]" % (options, args))

        if options.setup is None:
            parser.error("A setup file must be specified")

        if options.action is None:
            parser.error("An action must be specified")

        if options.action not in ok_actions:
            one_of = ", ".join(ok_actions)
            parser.error("The action specified must be one of: " + one_of)

        self.options = options
        self.setup   = options.setup
        self.action  = options.action

    def run(self):
        LOG.info("action: %s" % (self.action))
        LOG.info("setup: %s" % (self.setup))

        data = ''

        outfile = sys.stdout
        if self.options.outfile:
            outfile = open(self.options.outfile, 'w')

        infile = sys.stdin
        if self.options.infile:
            infile = open(self.options.infile, 'r')

        try:
            if self.action == 'get_notes':
                data = self.getNotes()
                outfile.write(data)
            elif self.action == 'get_elements':
                data = self.getElements()
                outfile.write(data)
            elif self.action == 'update_note':
                data = self.parseInfile(infile)
                self.updateNotes(data)
            elif self.action == 'new_note':
                data = self.parseInfile(infile)
                self.newNotes(data)
        except ClientConnectionError, e:
            LOG.error("Could not reach database: %s" % (e))
            sys.exit(2)

    def parseInfile(self, infile):
        data = []
        _re = re.compile(r'^(\w+):\s*(.+)$')
        count = int(infile.readline()[:-1])
        for line in infile.xreadlines():
            match = _re.search(line)
            if match != None:
                key = match.group(1)
                val = match.group(2)
                if key == 'id':
                    data.append({})
                data[-1][key] = val

        if len(data) != count:
            msg = "The number of elements read did not match count"
            LOG.error(msg)
            raise IOError(msg)

        return data

    def newNotes(self, data):
        client = Client()
        for entry in data:
            LOG.info("Running newNote()")
            client.newNote(self.setup, entry)

    def updateNotes(self, data):
        client = Client()
        for entry in data:
            LOG.info("Running updateNote()")
            client.updateNote(self.setup, entry)

    def getNotes(self):
        """
        Returns a serialized string representation of the notes
        """

        data = ''
        client = Client()

        LOG.info("Running getNotes()")
        notes = client.getNotes(self.setup)

        LOG.info("Lookup found: %s notes" % (len(notes)))
        LOG.info("Found this: %s", (notes))

        data += "%s\n" % (len(notes))

        for note in notes:
            LOG.info("---> note: %s" % (note))
            data += "id: %s\n" % (note.id)
            data += "user: %s\n" % (note.user)
            data += "text: %s\n" % (note.text)
            data += "is_checked: %s\n" % (int(note.is_checked))
            data += "date_added: %s\n" % (note.date_added.strftime(self.format))
            data += "date_modified: %s\n" % (note.date_modified.strftime(self.format))

        return data

    def getElements(self, outfile):
        """
        Returns a serialized string representation of the notes
        """

        print "Running getElements()"
        client = Client()
        elements = client.getElements(self.setup)
        print "Hey I got", len(elements), "elements"
        for element in elements:
            print "--->", elements

# ------------------------------------------------------------------------------
if __name__ == '__main__':
    app = Gateway()
    app.run()
